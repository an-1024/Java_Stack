# HashMap
## 1.为什么JDK 7使用数组+链表？JDK8中为什么要使用红黑树？哈希冲突是怎么回事？HashMap又是怎么解决的
> 首先解释一下什么是哈希冲突：hash 叫做 "散列表"。通过散列算法得到固定长度输出。输出结果叫做散列值。但是会在特殊的情况，不同的输入经过散列计算可能得到相同的散列值，此时不能通过散列值来确定唯一值。这种现象称之为 "Hash 冲突"
>
> 接着再来解释目前解决 Hash 冲突的几种方法：
>
>> 1.开放地址法（闭散列）：它的基本原则就是出现冲突后按照一定算法查找一个空位置存放。直到找到为止。开放地址法有三种实现方式：
>>> 线性探测再散列：顺序查看下一个单元，直到找出一个空单元或查遍全表
>>>
>>> 二次(平方)探测再散列：在表的左右进行跳跃式探测，直到找出一个空单元或查遍全表。
>>>
>>> 伪随机探测再散列：建立一个伪随机数发生器，并给一个随机数作为起点
>
>> 2.再哈希法：就是出现冲突后采用其他的哈希函数计算，直到不再冲突为止。
>
>> 3.链接地址法（拉链法）不同与前两种方法，他是在出现冲突的地方存储一个链表，所有的同义词记录都存在其中。形象点说就行像是在出现冲突的地方直接把后续的值摞上去。HashMap 就采用了这种算法。如图：
>> ![HashMap链地址法](photo/3.HashMap链地址法.png)
>
>> 4.建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表
>
> 总结四种方式的优缺点：
>> 开放地址法：容易序列化，若可预知数据总数，可以创建完美哈希数列。但是占用空间大，删除节点困难（不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。）。
>
>>
>> 再哈希法：节点不易产生聚集。但是增加了计算时间。
>
>> 链接地址法：处理冲突简单，无堆积现象。适合总数经常变化的情况。占空间小。删除结点的操作易于实现。同样也有缺点。查询时效率较低。（存储是动态的，查询时跳转需要更多的时间）。在key-value可以预知，以及没有后续增改操作时候，开放定址法性能优于链地址法。不容易序列化。
>
> 此时就解释了为什么 JDK7 使用数组+链表的存储书数据结构了。就是为了采用链表法解决存储时的哈希冲突。
>
> JDK 为什么在结构上又加了个红黑树？优化查询效率。当出现大量的哈希冲突的时候，HashMap 会变成一张线性表了，这会导致查询效率低下。
> 如图所示：
> ![HashMap底层数据存储结构](photo/2.HashMap底层数据存储结构.png)
> JDK 8 中为什么要使用红黑树？
>> 首先了解下数据结构中包含那些常见的"树"：
>>> 1.二叉树：每个节点的度不大于2。即每个节点最多有两个分支。通常称二叉树左右两个分支为左右子树。
>>> 
>>> ![二叉树](photo/4.二叉树.png) 
>>>
>>> 2.AVL树：AVL 规定任意一个节点对应两颗子树的最大高度差为1，这样的二叉树称为平衡二叉树。
>>> 
>>> ![AVL树](photo/5.AVL树.png)
>>> 
>>> 3.B树：一个 m 阶的B树是一个有以下属性的树
>>>> 1.每一个节点最多有 m 个子节点；
>>>>
>>>> 2.每一个非叶子节点（除根节点）最少有 ⌈m/2⌉ 个子节点；
>>>>
>>>> 3.如果根节点不是叶子节点，那么它至少有两个子节点；
>>>>
>>>> 4.有 k 个子节点的非叶子节点拥有 k − 1 个键；
>>>>
>>>> 5.所有的叶子节点都在同一层
>>> ![img.png](photo/6.B树-btreebuild.png)
>>>
>>> 4.B+树：在B+树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的阶数是m，则除了根之外的每个节点都包含最少 ⌊m/2⌋ 个元素，最多 m-1 个元素，对于任意的结点有最多 m 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。所有叶子都在相同的高度上，叶结点本身按关键字大小从小到大链接。
>>> 
>>>![img.png](photo/7.B+树.png)
>>> 红黑树：红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。
>> 总结：
