# 集合的作用(为什么要使用集合)
## 使用场景限制：
在程序中，经常会遇到需要一个“容器”来保存程序中需要处理的各种数据类型，这个容器指的就是数组。但是使用数组存储的数据类型比较单一，且长度在声明之后就不会再扩容，同时存放的元素可重复。这些缺点使得数组无法适配程序中各种各样的数据存储场景。因此 Java 产生了集合。
## 使用集合的好处：
从性能上来说集合提高了数据存储的灵活性，还可以动态扩容。
从使用复杂程度来说，Java JDK 中集成了各种集合，并且提供了各种 API 操作接口，更加方便开发使用。

从Java1.5引入了泛型，泛型允许我们为集合提供一个可以容纳的对象类型，不需要使用显式转换和instanceOf操作符，它也给运行时带来好处，因为不会产生类型检查的字节码指令。

# 集合
## 1. Vector与ArrayList
> 线程安全：
>> Vector：是线程安全的，内部方法使用 Synchronized 修饰，并发场景下，效率低下。
>> 
>> ArrayList：是非线程安全的。
> 
> 扩容：
>> Vector：在原有容量的基础上扩展 1 倍。
>>
>> ArrayList：在原油容量的基础上扩展 0.5 倍。
>> 
> 问题1：为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？
>> 一次增加固定值大小复杂度为：O(n)：
>>> 1. 假定有 n 个元素,每次增加k个；
>>> 2. 第i次增加复制的数量为为：ki；
>>> 3. n 次 push_back 操作所花费的时间复杂度为O(n^2)；
>>> 4. 均摊下来每次push_back 操作的时间复杂度为O(n)；
>>>
>>以成倍方式增长复杂度为：O(1)
>>> 1. 假定有 n 个元素,倍增因子为 m;
>>> 2. 完成这 n 个元素往一个 vector 中的 push_back 操作，需要重新分配内存的次数大约为 logm(n);
>>> 3. 第 i 次重新分配将会导致复制 m^(i) (也就是当前的vector.size() 大小)个旧空间中元素;
>>> 4. n 次 push_back 操作所花费的时间复制度为O(n);
>>> 5. m / (m - 1)是一个常量，均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间;
>>
> 问题1小结：增加固定大小容量，每次 push_back 的操作为 O(n)，以成倍的方式增长，每次 push_back 操作复杂度为 O(1)。因此以成倍的方式扩容。
> 
> 为标题2：为什么以成倍的方式扩容：
>> 根据大佬们的研究，成倍增长倍数不能太大，这样会导致空间的浪费。所以最好倍增长因子设置为(1,2)之间。另外相较于 2 倍增长，1.5 倍增长在几次扩容之后可以重复使用之前的内容。2 倍增长则不可以。
>> ![img.png](photo/1.1.5倍与2倍扩容比较.png)
